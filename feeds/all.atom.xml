<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>seaandsailor</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2016-12-01T12:00:00-05:00</updated><entry><title>Model checkpointing using meta-graphs in TensorFlow</title><link href="/tensorflow-checkpointing.html" rel="alternate"></link><updated>2016-12-01T12:00:00-05:00</updated><author><name>jfsantos</name></author><id>tag:,2016-12-01:tensorflow-checkpointing.html</id><summary type="html">&lt;p&gt;Deep learning models usually take a while to train, even on GPUs, so being able
to checkpoint intermediate stages in training is really important. Frameworks
like &lt;a href="http://keras.io"&gt;Keras&lt;/a&gt; usually offer functionality to store learned
variables like weights and biases, but for resuming training for a checkpoint,
one might also need to restore the optimizer state (that will be the case if
you use any optimizer that stores any kind of state, like Adam). Ideally, we
would like to store &lt;em&gt;everything&lt;/em&gt; it needs and not have to reinstantiate the
entire graph again, and this is possible in TensorFlow by using meta-graphs.&lt;/p&gt;
&lt;p&gt;After checking the &lt;a href="https://www.tensorflow.org/versions/r0.11/how_tos/meta_graph/index.html"&gt;documentation&lt;/a&gt; on
meta-graphs, I tried to quickly hack an example but there were a few gotchas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if you don't name your variables passing the &lt;code&gt;name='name'&lt;/code&gt; argument when you
  create them, you will have a hard time trying to get their values&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;variables that are not stored in collections cannot be easily retrieved&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this procedure, even if done correctly, will only store your TensorFlow graph
  and variables that are part of it. This usually does not include in which
  epoch/iteration the training procedure was when it stopped.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I found an
&lt;a href="http://stackoverflow.com/questions/38829641/tensorflow-train-import-meta-graph-does-not-work"&gt;example&lt;/a&gt;
that illustrates how to solve the first two issues on Stack Overflow. The
latter one, while trivial, is also a common use case when you train your models
in environments you cannot control (like Amazon EC2, Microsoft Azure, your
university cluster, or even your own computer if you have a power failure!), so
I decided to prepare a simple
&lt;a href="https://gist.github.com/jfsantos/bc37eb9bc506a6f165152d676e3ccd42"&gt;example&lt;/a&gt;
that covers that case as well. The example is based on the &lt;a href="https://github.com/aymericdamien/TensorFlow-Examples"&gt;logistic regression
tutorial&lt;/a&gt; by Aymeric
Damian (which, by the way, is a great resource if you are just learning
TensorFlow).&lt;/p&gt;
&lt;p&gt;To test the example, do the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the file without any arguments (&lt;code&gt;python
   logistic_regression_with_checkpointing.py&lt;/code&gt;). It will run for 5 epochs and
   save checkpoints for each epoch.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run file again, now passing &lt;code&gt;--load
   True --max_epochs 10&lt;/code&gt; as arguments. The script will detect it has already
   trained for 5 epochs, and run for another 5 epochs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You will end up with a bunch of files called &lt;code&gt;model.ckpt-{epoch}&lt;/code&gt; and
&lt;code&gt;model.ckpt-{number}.meta&lt;/code&gt;. The former will contain your variable values, and
the latter (the ones ending in &lt;code&gt;.meta&lt;/code&gt;) store the meta-graph. When running with
&lt;code&gt;--load True&lt;/code&gt;, the code will determine when we last saved the model (&lt;a href="https://gist.github.com/jfsantos/bc37eb9bc506a6f165152d676e3ccd42#file-logistic_regression_with_checkpointing-py-L62"&gt;lines
62-65&lt;/a&gt;),
create a new &lt;code&gt;tf.train.Saver&lt;/code&gt; object based on the exported meta-graph, and
later restore the model parameters and also placeholders and operations we need
in order to continue training (in this case, the placeholders &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and
the operations to compute the cost function, update the model, and do inference
with it).&lt;/p&gt;
&lt;p&gt;I wrote this example for myself but hope it will be useful for other people. If
you are reading this, that is probably the case!&lt;/p&gt;</summary><category term="development"></category></entry><entry><title>A really brief introduction to audio signal processing in Julia</title><link href="/audiosp_julia.html" rel="alternate"></link><updated>2014-11-03T23:00:00-05:00</updated><author><name>jfsantos</name></author><id>tag:,2014-11-03:audiosp_julia.html</id><summary type="html">&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;If you are into scientific computing, you probably have already heard
about &lt;a class="reference external" href="http://julialang.org"&gt;Julia&lt;/a&gt;, the magical language that aims
to be (almost) as fast as C and as easy as MATLAB and Python to write. I
have been playing with Julia for more than a year now, and I really like
it and recommend checking it out.&lt;/p&gt;
&lt;p&gt;The objective of this post is not to teach you Julia. Hopefully,
everything used here is so similar to MATLAB or Python you will not need
any explanation on what is happening :) The main idea here is to show
the basic tools we already have available in
&lt;a class="reference external" href="https://github.com/JuliaDSP/DSP.jl"&gt;DSP.jl&lt;/a&gt; (disclaimer: I am one of
the developers!) and give you something to play with.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="setup"&gt;
&lt;h2&gt;Setup&lt;/h2&gt;
&lt;p&gt;To be able to run the code in this post (also distributed as an IJulia
notebook), you will need to install
&lt;a class="reference external" href="http://julialang.org/downloads"&gt;Julia&lt;/a&gt; (of course!) and the
following packages:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/JuliaDSP/DSP.jl"&gt;DSP.jl&lt;/a&gt;: signal processing functions (filtering, spectrograms/periodograms, window functions...).&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/dancasimiro/WAV.jl"&gt;WAV.jl&lt;/a&gt;: loading/writing WAV files.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/stevengj/PyPlot.jl"&gt;PyPlot.jl&lt;/a&gt;: a Julia interface to the &lt;a class="reference external" href="http://matplotlib.org"&gt;Matplotlib&lt;/a&gt; plotting library. This is actually a Python library, but there is very little overhead (for examples, arrays are passed to it without making copies).&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/JuliaLang/IJulia.jl"&gt;IJulia.jl&lt;/a&gt;: where the magic happens :) IJulia notebooks work exactly like IPython notebooks. In fact, they all share the same infrastructure (more on this &lt;a class="reference external" href="http://jupyter.org"&gt;here&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Installing packages in Julia is easy. Just run the following commands in
the Julia REPL:&lt;/p&gt;
&lt;pre class="code julia literal-block"&gt;
&lt;span class="n"&gt;Pkg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# only needed if this is the first time you are dealing with packages&lt;/span&gt;
&lt;span class="n"&gt;Pkg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Pkg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;PackageName&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;where &amp;quot;PackageName&amp;quot; is the name of the package you want to install
(&lt;em&gt;without&lt;/em&gt; the .jl suffix).&lt;/p&gt;
&lt;p&gt;If you want to follow along using the notebook, you can download it from this &lt;a class="reference external" href="https://github.com/jfsantos/IJuliaNotebooks"&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="loading-visualizing-and-processing-an-audio-file"&gt;
&lt;h2&gt;Loading, visualizing, and processing an audio file&lt;/h2&gt;
&lt;pre class="code julia literal-block"&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;DSP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WAV&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyPlot&lt;/span&gt; &lt;span class="c"&gt;# &amp;quot;using&amp;quot; makes the listed modules available for the&lt;/span&gt;
                       &lt;span class="c"&gt;# user, like &amp;quot;import&amp;quot; in other languages&lt;/span&gt;

&lt;span class="c"&gt;# Loading and plotting an audio signal&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wavread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test.wav&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Time [s]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;img alt="" src="images/output_2_0.png" /&gt;
&lt;pre class="code julia literal-block"&gt;
&lt;span class="c"&gt;# PyPlot includes a specgram function, but let's use the native&lt;/span&gt;
&lt;span class="c"&gt;# implementation from DSP.jl. The function below extracts a&lt;/span&gt;
&lt;span class="c"&gt;# spectrogram with standard parameters for speech (25ms Hanning windows&lt;/span&gt;
&lt;span class="c"&gt;# and 10ms overlap), then plots it and returns it .&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="nf"&gt; plot_spectrogram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;spectrogram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;convert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;25e-3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                    &lt;span class="nb"&gt;convert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;10e-3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;hanning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;freq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;imshow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flipud&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log10&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;))),&lt;/span&gt; &lt;span class="n"&gt;extent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
             &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)],&lt;/span&gt; &lt;span class="n"&gt;aspect&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;auto&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;S&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="code julia literal-block"&gt;
&lt;span class="n"&gt;plot_spectrogram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;img alt="" src="images/output_4_0.png" /&gt;
&lt;pre class="code julia literal-block"&gt;
&lt;span class="c"&gt;# Now let's bandpass the signal to simulate telephone bandwidth&lt;/span&gt;
&lt;span class="c"&gt;# and plot its spectrogram again&lt;/span&gt;
&lt;span class="n"&gt;responsetype&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Bandpass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3400&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;prototype&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Butterworth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;telephone_filter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;digitalfilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;responsetype&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# Let's take a look at the filter response now&lt;/span&gt;
&lt;span class="err"&gt;ω&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt; &lt;span class="c"&gt;# variables can have Unicode names!&lt;/span&gt;
              &lt;span class="c"&gt;# This is typed in the notebook as \omega + tab.&lt;/span&gt;
&lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;freqz&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;telephone_filter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;ω&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="err"&gt;ω&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;log10&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Frequency [Hz]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Gain [dB]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# Filtering our signal with the filter&lt;/span&gt;
&lt;span class="n"&gt;sf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;filt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;telephone_filter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;img alt="" src="images/output_5_0.png" /&gt;
&lt;pre class="code julia literal-block"&gt;
&lt;span class="c"&gt;# Just to be sure the filter has done the right thing, let's see&lt;/span&gt;
&lt;span class="c"&gt;# the spectrogram of the filtered signal&lt;/span&gt;
&lt;span class="n"&gt;plot_spectrogram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;img alt="" src="images/output_6_0.png" /&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="c"&gt;# IJulia still does not support playing audio, so we include&lt;/span&gt;
&lt;span class="c"&gt;# some code to do it.&lt;/span&gt;
&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;AudioDisplay.jl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;AudioDisplay&lt;/span&gt;

&lt;span class="n"&gt;audioplayer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;audioplayer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;audio controls="controls" {autoplay}&gt;
&lt;source src="data:audio/wav;base64,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SAEkOygBFDsoAZQ6UAEoOlwBLjt4ATw7UAGoOhgBjDpoAbQ6qAHUOugB9DrIAeQ6iAHEOoABwDooAZQ60AFoOnABuDrQAWg6UAEoOoABQDmAAUA5GAGMOgABALjAAeC5MAEYukABILpAASC5EAGIugABALvIAeS6kAFIuqAB0Lr4Afy6mAHMurgB3Lr4Afy6HAEOu2ABsLqAAcC5CAGEugwBBrsAAYC6IAGQuSABEDoAAQA4gAHAuEABILlAASA5YAGwOsgB5DogARA7AAGAOmABMDqYAcw6EAEIO7gB3DrgAXA6kAFIOpgBzDq4Adw6SAGkOsABYDqYAcw6uAHcOgABgDkAAQA6CAGEOhABCDpQASg6wAFgOkABoDkgAZA5AAEAugABgLowAZi6IAGQulABKLqQAci6IAGQukABILpgAbC6kAHIutABaLogARC6AAGAusABYLoAAQC5IAGQuSABEDrQAWg6AAEAuMABYDkAAYC4AAEAOgABADoAAAAAgAHAOAABgLgAAYA5QAEgOoABwDnAAeA54AHwOQABgDiAAUC5YAGwOYABQLoYAYy6QAEgOgABADhYAay6MAGYumABMLrAAWC6wAFguuABcLpAAaC66AH0unABOLqAAcC4QAGgudABaLqIAcS6CAGEupABSLo4AZy6GAGMukABILrAAWC5KAGUOoABQDpAASA5IAGQOaABUDrwAXg6gAHAOEABIDrAAWA6QAGgOcABYLkAAYC5QAEgOmABsDkQAYi6GAGMurABWLpgATC6gAFAudABaLowAZi6AAEAugABgDmAAUA5sAFYukgBpLrAAeC5gAHAuVgBrLogAZC5IAEQOoABQLnwAXi6oAHQuQABADqAAcA4EAEIugABALrAAWC5EAEIOlABKDqgAdC5QAEguuAB8DkQAQg6UAEoOrABWDoAAYC5AAGAONABaDqQAUg6MAEYOgAAAACQAUi6UAEougABALlAASA5UAEouhABCLpgAbC5QAGguSABkLlwATi6MAEYunABOLqQAUi6IAEQutABaLrgAfC5IAGQOcABYLmAAcA4EAEIOiABkDlAAaA5gAFAOUABIDkAAYA5AAEAOAABgLkgAZC5gAHAOHABOLoQAYi6gAFAOQABALlIAaS6IAGQumABsLnAAeC5IAGQuYABQLkgARC6YAEwulABKLqQAUi64AHwuYABQDmAAcC5AAGAumABsLkAAAAAAAGAuIABwDgAAYC5UAEouoABwDigAVA6oAHQOeABcDpwATg6IAGQOXABODoQAYg6EAEIOoABQLlgATA6GAGMOsABYDrAAWA5QAEguUABoDlgAbA5AAEAOAABgLlQASi6AAGAuQABALhgAbA5AAAAAAABgLigAdA5AAAAAAAAAABAASA64AFwOsAB4DmAAUA5EAEIOpAByDrQAWg6QAEgOgABgDrQAWg6gAFAOkABIDrAAWA6cAG4OtAB6DooAZQ6aAG0OnABuDoQAQg6gAFAOlgBrDpQASg6YAEwOgABgDpIAaQ68AF4OlABKDrgAXA64AFwOnABODoAAAAAQAEguSABEDpgAbA6sAFYOsAB4DkgAZA5cAE4OnABODogAZA5QAEguuAB8LkQAQg6wAFguUABoLkAAQC4AAGAOAABALiAAcC5MAEYumABsLlgATC60AFouuAB8LkAAYC5QAEgueABcLpwAbi6sAFYukABoLlgATC6kAHIuhABiLoAAQC4YAGwuYABwLkgAZC5AAEAuYABQLqgAVC6AAGAuUABoLkAAYC5AAGAuYABwLkAAQA6QAEgOoABwLgAAQA4AAEAOQABADqAAUC5EAEIugAAAADAAWA5AAAAAAAAAAAAAQA4AAGAuEABoLkAAQC6gAHAuYABwLkAAYC4QAEgusAB4LkAAYA5AAEAuQABgLhgAbA5AAEAOEABoLnAAeC5oAHQuUABILmAAcC4QAEguqABULoAAYC5IAEQusAB4LmgAdC5UAEouiABkLqgAVC6wAHgucABYLqgAdC5AAAAAIABwDhAASA5AAAAAEABILlAASA5gAHAOMABYLmAAcC5MAEYugABgLgAAQA6AAEAOgABgLhAASC5gAFAOQABgDlAASA5IAGQOaAB0DkAAQA6wAFgOYABQDkQAQg6MAEYOoABQDkwARi6wAFguQABADggARC6EAEIukABIDmAAcA5AAAAAAABADpQASg6sAFYOtABaDoAAQA6IAEQOqAB0DlwATg6YAEwOnABODogARA6EAEIOjgBnDo4AZw6oAHQOSABkDnAAWA6AAEAOgABgDmgAdA5QAEgOcAB4DnAAWA6QAEgOmABsDkAAQA5AAGAOEABIDkAAYA5AAEAOcABYDkQAQg6IAGQOYABwDmAAcA5UAEoOhABCDoAAQA5QAEgOQABADlgAbA5AAEAOWABMLrAAWC6gAHAOWABsDnwAXi6gAHAukABILqAAcC5gAFAukABoLpIAaS6IAEQurABWLrAAWC6IAEQuhABCLrgAfC5YAGwuQABALkAAQC4gAHAuEABIDnAAWC5IAGQuSABkDmAAUA6wAFgOiABEDoAAQA5gAFAOUABIDogAZA5AAEAOcABYDlwATg64AFwOnABODowARg6kAFIOnABODpAASA6QAEgOcAB4DlgATA6AAEAOkABIDkAAYA4AAEAOoABQDnAAWC5UAEoumABMLogAZC5QAEguUgBpLp4Aby6cAE4uoABQLrwAXi6mAHMusAB4LpwAbi6EAGIuvABeLo4AZy6SAGkukgBpLrwAXi6cAE4utABaLpYAay6MAGYulABKLrAAWC64AFwugABgLpwATi6IAGQucABYLlAAaC5YAGwuQAAAAAAAQC4QAEgOQABADlAASC5AAEAuQAAAABgAbA5oAHQOYABwDhAASC5AAEAuGABsDlgAbA5EAEIOrABWDogARA68AF4OlgBrDpYAaw6" type="audio/wav" /&gt;
Your browser does not support the audio element.
&lt;/audio&gt;&lt;br&gt;
&lt;audio controls="controls" {autoplay}&gt;
&lt;source src="data:audio/wav;base64,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" type="audio/wav" /&gt;
Your browser does not support the audio element.
&lt;/audio&gt;&lt;p&gt;(Just a sidenote: the
&lt;a class="reference external" href="https://github.com/ssfrr/AudioIO.jl"&gt;AudioIO.jl&lt;/a&gt; module has more
advanced functions for loading and playing audio, but in this example I
wanted to use the notebook for all multimedia rendering.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="where-to-go-from-here"&gt;
&lt;h2&gt;Where to go from here?&lt;/h2&gt;
&lt;p&gt;I know this is all really basic, but Julia has much more to offer. There
are currently &lt;a class="reference external" href="http://pkg.julialang.org"&gt;429 packages&lt;/a&gt; (and counting)
available to install via the package manager and much more in
development on GitHub. Package development has been especially strong in
the &lt;a class="reference external" href="https://juliastats.github.io"&gt;statistics/machine learning&lt;/a&gt; and
&lt;a class="reference external" href="http://www.juliaopt.org"&gt;optimization&lt;/a&gt; domains.&lt;/p&gt;
&lt;p&gt;If you want to learn more about the language, check the &lt;a class="reference external" href="http://docs.julialang.org/en/release-0.3/"&gt;official
documentation&lt;/a&gt; and the
&lt;a class="reference external" href="http://julialang.org/learning/"&gt;learning resources&lt;/a&gt; at the website.
There is also a very active &lt;a class="reference external" href="https://groups.google.com/forum/?fromgroups=#!forum/julia-users"&gt;mailing list for
users&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I sincerely hope you find Julia interesting and worth of your time!&lt;/p&gt;
&lt;/div&gt;
</summary><category term="development"></category></entry><entry><title>Configuring MATLAB to work with XCode 6 on Yosemite</title><link href="/matlab-xcode6.html" rel="alternate"></link><updated>2014-10-28T17:00:00-04:00</updated><author><name>jfsantos</name></author><id>tag:,2014-10-28:matlab-xcode6.html</id><summary type="html">&lt;p&gt;After I upgraded my Mac to Yosemite (10.10), I had a lot of trouble to get MATLAB 2013a working properly. First, I started getting a NullPointerException from Java when trying to start it. Turns out this was a problem with some Java classes used for drawing MATLAB's GUI and Mathworks released some &lt;a class="reference external" href="http://www.mathworks.com/support/bugreports/1098655"&gt;patches&lt;/a&gt; for MATLAB versions from R2012b to R2014a (the bug was fixed in R2014b).&lt;/p&gt;
&lt;p&gt;Unfortunately, that was not the only issue. Since I also upgraded to XCode 6, I was not able to compile MEX files anymore. I checked the system requirements at the &lt;a class="reference external" href="http://www.mathworks.com/support/sysreq/previous_releases.html"&gt;Mathworks website&lt;/a&gt;  and it states that R2013a and R2013b support XCode 4.3 or higher, and R2014a supports either 4.6+ or 5.0. From my previous experience, I know sometimes these are &amp;quot;soft&amp;quot; requirements and I managed to make MATLAB work with unsupported compilers (like different versions of Visual Studio on Windows, or different versions of GCC on Linux). However, on a Mac the command &lt;code&gt;mex -setup&lt;/code&gt; only gives you an option to keep your current compiler configuration or copy the default file to your home folder. Here's what I did to make MATLAB work with XCode 6:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Run &lt;code&gt;mex -setup&lt;/code&gt; and ask it to copy the default &lt;code&gt;mexopts.sh&lt;/code&gt; to my home folder.&lt;/li&gt;
&lt;li&gt;Edit &lt;code&gt;/Users/myusername/.matlab/R2013a/mexopts.sh&lt;/code&gt;, replacing all instances of &lt;code&gt;10.8&lt;/code&gt; to &lt;code&gt;10.10&lt;/code&gt; in the section corresponding to Mac 64 bits (i.e., everything after the line &lt;code&gt;maci64)&lt;/code&gt; and the end of the file).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After doing this, calling &lt;code&gt;mex&lt;/code&gt; worked, but I was still not able to compile my MEX files. The error message I got was the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;error: unknown &lt;span class="nb"&gt;type &lt;/span&gt;name &lt;span class="s1"&gt;&amp;#39;char16_t&amp;#39;&lt;/span&gt;
typedef char16_t CHAR16_T;&lt;span class="sb"&gt;`&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Turns out the compiler that ships with XCode 6 (Clang) does not set &lt;code&gt;char16_t&lt;/code&gt;, as explained in this helpful Stack Overflow &lt;a class="reference external" href="http://stackoverflow.com/questions/22367516/mex-compile-error-unknown-type-name-char16-t"&gt;post&lt;/a&gt;. Instead of having to remember to set this to &lt;code&gt;UINT16_T&lt;/code&gt; every time I compile a MEX file or editing the source, I decided to add this to my &lt;code&gt;mexopts.sh&lt;/code&gt; file, which leads us to the third and final step:&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;Replace the line that reads &lt;code&gt;CFLAGS=&amp;quot;$CFLAGS  -fexceptions&amp;quot;&lt;/code&gt; by &lt;code&gt;CFLAGS=&amp;quot;$CFLAGS  -fexceptions -Dchar16_t=UINT16_T&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After adding this, MATLAB happily compiled all of the MEX files I tested, even some I had generated with MATLAB Coder.&lt;/p&gt;
</summary><category term="development"></category></entry><entry><title>Using stochastic neurons for conditional computation</title><link href="/stochastic_neurons_conditional.html" rel="alternate"></link><updated>2014-04-27T16:00:00-04:00</updated><author><name>jfsantos</name></author><id>tag:,2014-04-27:stochastic_neurons_conditional.html</id><summary type="html">&lt;p&gt;As stated in my previous &lt;a class="reference external" href="/gammatone.html"&gt;post&lt;/a&gt;, I had some issues when trying to train
my network while using sparse-coded speech frames as input/output. The
network was getting stuck at the same point after processing a single
batch, and processing additional batches did anything training-wise
(performance, weights, etc., were all stuck). I tried different
initialization ranges for the weight matrices, a different learning
rate, different network architectures (unit types, different number of
units and layers) but the results were still the same.&lt;/p&gt;
&lt;p&gt;In the same post, I talked about sparsity not being enforced at the
output. Since the whole dataset was sparse-coded and we were trying to
predict the vector of sparse coefficients for the next frame, all
outputs were expected to be as sparse as the inputs. This post
describes what I did to try to mitigate this issue. I used stochastic
neurons that enforce sparsity in the output layer of a network with
the same architecture as the previous network. This brings in the
problem of propagating gradients through stochastic units, but
fortunately David Warde-Farley pointed me to a paper which presents
some alternative solutions &lt;a class="citation-reference" href="#bengio2013" id="id1"&gt;[Bengio2013]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The units I used at the output layer are similar to the ones called
&amp;quot;Stochastic times Smooth&amp;quot; (STS) in &lt;a class="citation-reference" href="#bengio2013" id="id2"&gt;[Bengio2013]&lt;/a&gt;. The idea is that the
output of a neuron is equal to the product of a stochastic part
(sampled from a binomial distribution with probability
&lt;span class="math"&gt;\(\sqrt{p_i}\)&lt;/span&gt;
) and a smooth part (for example, a sigmoid or a
linear function). The value of &lt;span class="math"&gt;\(p_i\)&lt;/span&gt;
 itself comes from a
non-linear computation based on the unit's input. The stochastic
part serves as a &amp;quot;gater&amp;quot; which prevents the activation with a
probability determined by the activation at the &amp;quot;gater path&amp;quot; of the
unit. A sparsity constraint is imposed by a combination of the
KL-divergence criterion for the sigmoids in the &amp;quot;gater path&amp;quot; of the
unit with added noise (as explained in sections 1 and 2 of Appendix A
in the referred paper).&lt;/p&gt;
&lt;!-- add image showing how the STS unit is structured --&gt;
&lt;p&gt;I found an implementation for these units by one of the authors
(Nicholas Léonard) at &lt;a class="reference external" href="https://github.com/nicholas-leonard/delicious"&gt;GitHub&lt;/a&gt;, and updated it to the current Pylearn2
interface. His implementation had support for &amp;quot;hybrid&amp;quot; STS units which
are semi-stochastic (i.e., part of the output is deterministic), but I
did not use it. These units have a 2-layer non-linear gater path (I
used two sigmoidal layers) and a linear path for the output.&lt;/p&gt;
&lt;p&gt;Now, for the results: sadly, switching to these units made no
significant difference at first. I did some tests using the same
training/testing/validation sets from Vincent's TIMIT dataset but
filtering it such that there were only sentences from male
speakers. The network was still stuck at the same objective value
after the first epoch. So, I decided to take a look on an alternative
hypothesis: maybe less sparsity/a different sparse coding
configuration could help?&lt;/p&gt;
&lt;div class="section" id="using-an-undercomplete-gammatone-dictionary"&gt;
&lt;h2&gt;Using an undercomplete gammatone dictionary&lt;/h2&gt;
&lt;p&gt;After I have seen that tinkering with the hyperparameters and
switching the output layer to an STS layer did not solve my problem, I
decided to play a bit with the inputs/outputs I was using. My sparse
coding scheme was resulting in a very sparse representation, as each
frame with 160 samples was being represented by up to 16 sparse coding
coefficients. Since the dictionary had 950 different atoms, it means
that only approximately 1.7% of the coefficients were non-zero, both
in the input and in the output. Note that while the quality of the
reconstruction is acceptable (as you can listen in the samples below),
this gives us no idea on whether it is a good representation
phone-wise (i.e., if there's any relationship between the chosen atoms
and specific phones). Given the poor results I had with the previous
representation, I guess the representation I chose could be one of the
culprits for the bad performance.&lt;/p&gt;
&lt;p&gt;To test the effect of a different sparse representation, I decided to
switch the dictionary used by my sparse coding scheme to an
undercomplete dictionary (i.e., a dictionary where the number of atoms
is smaller than the length of each atom), using longer frames and
increasing the overlap to 87.5% instead of 50%. Another thing that
motivated this change was realizing my previous dictionary still had a
big problem: a dictionary with atoms with length 160 was not able to
hold full atoms for frequencies lower than 1000 Hz, as the envelope
for lower frequency atoms decay is slower than for high-frequency
ones. To be able to have atoms for the desired frequency range (150 to
8000 Hz), I would need to increase the atom length. However, the
tradeoff between atom length and number of atoms in an overcomplete
dictionary would make the sparse coefficient vector even longer than
the one I had (950 coefficients). I made some experiments with an
undercomplete dictionary with longer frames (1600 samples, equivalent
to 100 ms at 16 kHz sampling rate) and more frequency values for the
gammatones (64, instead of 50), and felt that the reconstruction
quality decreased a bit. However, increasing the overlap between
samples led to a decent reconstruction quality. You can listen to the
original sample and the three reconstructed samples below:&lt;/p&gt;
&lt;p&gt; Original: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/original.ogg" type="audio/ogg" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;

&lt;p&gt; Reconstructed with "wrong" overcomplete dictionary (length 160, overlap 50%, atoms not correctly limited at frame borders): &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/reconst_160_80.ogg" type="audio/ogg" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;

&lt;p&gt; Reconstructed with undercomplete dictionary (length 1600, overlap 50%): &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/reconst_1600_800.ogg" type="audio/ogg" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;

&lt;p&gt; Reconstructed with undercomplete dictionary (length 1600, overlap 87.5%): &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/reconst_1600_1400.ogg" type="audio/ogg" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;&lt;p&gt;The final dictionary I used had an atom length of 1600 and 1536 atoms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="trouble-with-a-capital-t-as-in-import-theano-tensor-as-t"&gt;
&lt;h2&gt;Trouble with a capital T (as in &lt;tt class="docutils literal"&gt;import theano.tensor as T&lt;/tt&gt;)&lt;/h2&gt;
&lt;p&gt;Unfortunately, even after switching the previous dataset by the one
generated with the undercomplete dictionary, the behavior of my
network during training was still the same... with the added problem
of NaNs appearing eventually after being stuck for around 30
iterations (with &lt;a class="reference external" href="https://github.com/jfsantos/ift6266h14/blob/master/experiments/mlp_sparse/sp1600_conditional.yaml"&gt;this&lt;/a&gt; YAML file, which uses only a bunch of sentences
from the validation set to save processing time). I am not sure on
what is causing this and searching at the &lt;a class="reference external" href="https://groups.google.com/forum/#!topic/pylearn-users/yr-i_RzY9a0"&gt;pylearn-users&lt;/a&gt; mailing
list, I have seen that David Krueger also had a &lt;a class="reference external" href="http://dskspeechsynthesis.wordpress.com/2014/04/25/no-more-nans/"&gt;similar issue&lt;/a&gt;
recently. In my case, using the &lt;tt class="docutils literal"&gt;nan_guard&lt;/tt&gt; as suggested by Ian in
this thread showed that the error happened during the computation of a
weight matrix inside the STS layer, namely the second weight matrix
used in the gater path of the unit (second layer of the non-linear
part). The error log is very low level as you can see &lt;a class="reference external" href="files/0.err"&gt;here&lt;/a&gt;, which
makes sense since it comes from inside an optimized Theano
graph. Altering the sparsity target in the output layer seems to avoid
this, but the results are still the same. Additionally, the predicted
coefficients are very far from the sparsity target I have set for the
output layer: 10% of the coefficients should be non-zero, but I am
getting something close to 50% instead (approximately 750 non-zero
coefficients per frame).&lt;/p&gt;
&lt;p&gt;Here is an example of an audio file generated with the trained
network, using the previous frame and the previous, current, and next
phone as input:&lt;/p&gt;
&lt;p&gt; &lt;audio controls="controls" &gt;
      &lt;source src="files/test_sparse.ogg" type="audio/ogg" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;&lt;p&gt;(Yes, it does not sound like speech at all.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ideas-for-the-future"&gt;
&lt;h2&gt;Ideas for the future?&lt;/h2&gt;
&lt;p&gt;None of my experiments led to results that would convince one that
using a sparse representation based on gammatones would be a useful
thing for speech synthesis. Architectures using time-domain audio
samples as the input/output had much more exciting results. Looking
forward, I would like to experiment with my other representation based
on the gammatonegram and convolutional neural nets. As the
gammatonegram for consecutive frames can be seen as an image (where
each time-frequency cell is a &amp;quot;pixel&amp;quot;), the usual 2D CNNs could be
tested.&lt;/p&gt;
&lt;p&gt;Even though our course is over, my PhD research topic is speech
processing, so I believe I'll continue playing with deep learning in
the future. I am interested in investigating applications of deep
learning to speech enhancement systems. There is a very recent paper
(to appear in this year's ICASSP) where the authors used a DNN to
learn spectral masks to reduce reverberation in speech signals
&lt;a class="citation-reference" href="#han2014" id="id3"&gt;[Han2014]&lt;/a&gt;. It would be interesting to see if a similar idea could be
used not only for reverberation, but for speech enhancement under
different kinds of environment. Other ideas will hopefully pop-up
along the way!&lt;/p&gt;
&lt;table class="docutils citation" frame="void" id="bengio2013" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[Bengio2013]&lt;/td&gt;&lt;td&gt;&lt;em&gt;(&lt;a class="fn-backref" href="#id1"&gt;1&lt;/a&gt;, &lt;a class="fn-backref" href="#id2"&gt;2&lt;/a&gt;)&lt;/em&gt; Y. Bengio, N. Léonard, and A. Courville, “Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation,” arXiv:1308.3432 [cs], Aug. 2013.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="han2014" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[Han2014]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;K. Han, Y. Wang and D. Wang, “Learning spectral mapping for speech dereverberation”, To appear in the Proceedings of the IEEE ICASSP 2014, 2014. Available at &lt;a class="reference external" href="http://www.cse.ohio-state.edu/~dwang/papers/HWW.icassp14.pdf"&gt;http://www.cse.ohio-state.edu/~dwang/papers/HWW.icassp14.pdf&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="ift6266"></category></entry><entry><title>Using an auditory-inspired representation for speech</title><link href="/gammatone.html" rel="alternate"></link><updated>2014-03-31T14:00:00-04:00</updated><author><name>jfsantos</name></author><id>tag:,2014-03-31:gammatone.html</id><summary type="html">&lt;p&gt;I &lt;a class="reference external" href="http://www.seaandsailor.com/dict_learning.html"&gt;previously&lt;/a&gt;
described an approach to representing speech signals by decomposing
them to an arbitrary dictionary (using a sparse coding algorithm such
as Orthogonal Matching Pursuit). In that post, I showed that learning
a representation from the data by using a dictionary learning method
could be useful. However, there were some problems with that
approach. First, the dictionary atoms were not localized in time: the
atoms I learned from the data were waveforms spreading throughout the
entire frame. This behavior has led to issues when reconstructing the
signal, as nothing guarantees the last sample in the &lt;span class="math"&gt;\(k^{th}\)&lt;/span&gt;

frame will be close to the first sample in the &lt;span class="math"&gt;\(k+1^{th}\)&lt;/span&gt;

frame. The second issue was related to not using overlapped windows to
split/resynthesize the signal. This is one of the main reasons that
made the signals I generated previously so noisy.&lt;/p&gt;
&lt;p&gt;In order to solve these problems, I added two updates to my previous
code:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Dropped the dictionary I learned from the data and switched to a
gammatone dictionary.&lt;/li&gt;
&lt;li&gt;Generated the audio frames using Hamming windows with 50% overlap.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the next sections, I will give a brief description and motivation
for each of these updates. I will also show why they didn't work as
well as I expected and inspired another architecture.&lt;/p&gt;
&lt;div class="section" id="gammatone-functions-and-gammatone-based-dictionary"&gt;
&lt;h2&gt;Gammatone functions and gammatone-based dictionary&lt;/h2&gt;
&lt;p&gt;Gammatone filters are a popular way of modeling the auditory
processing at the cochlea. Basically, the cochlea is interpreted as a
filterbank whose impulse response follows the following equation (the
product of a &lt;em&gt;gamma&lt;/em&gt; function and a cosine, or a &lt;em&gt;pure tone&lt;/em&gt;):&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g(t) = at^{n-1}e^{-2\pi b t}\cos(2 \pi ft + \phi)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;In this equation, &lt;span class="math"&gt;\(b\)&lt;/span&gt;
 corresponds to the filter's bandwidth,
&lt;span class="math"&gt;\(n\)&lt;/span&gt;
 is the filter order, &lt;span class="math"&gt;\(f\)&lt;/span&gt;
 is the central frequency, and
&lt;span class="math"&gt;\(\phi\)&lt;/span&gt;
 is the phase of the carrier. The first two parameters can
be fixed for the entire filterbank, while the center frequencies
&lt;span class="math"&gt;\(f\)&lt;/span&gt;
 are usually defined according to the cochlea's critical
frequencies. One way of computing these frequencies is by using the
Equivalent Rectangular Bandwidth (ERB), which gives an approximation
to the bandwidths of the human auditory filters:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
ERB_j = \frac{f_j}{Q_{ear}} + B_{min}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Here, &lt;span class="math"&gt;\(Q_{ear} = 9.26449\)&lt;/span&gt;
 and &lt;span class="math"&gt;\(B_{min} = 24.7\)&lt;/span&gt;
 are
constants corresponding to the Q factor and minimum bandwidth of human
auditory filters.&lt;/p&gt;
&lt;p&gt;Gammatone functions are used in auditory modelling because they match
the resonance of different regions in the cochlea. As shown in
&lt;a class="citation-reference" href="#smith2006" id="id1"&gt;[Smith2006]&lt;/a&gt;, human speech can be sparsely represented by gammatone
atoms. &lt;a class="citation-reference" href="#strahl2008" id="id2"&gt;[Strahl2008]&lt;/a&gt; has later shown that a sparse gammatone model can
be optimized for English speech, even though the optimized model does
not match the human auditory filters anymore.&lt;/p&gt;
&lt;p&gt;A gammatone dictionary can be built similarly to a Gabor dictionary,
as gammatones are localized both in time and frequency. First, we have
to choose a set of frequencies; usually, you pick the number of
frequencies you want and the range, and use the ERB equation to find
equally-spaced frequencies in the ERB space (these would be the so
called critical frequencies). Then, we select the resolution of our
atoms (which has to be less or equal to the frame length in our
application) and then time-shift the atoms inside the frame by a
specified amount. The following Python code does that (and also
normalizes the dictionary at the end):&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gammatone_matrix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;resolution&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Dictionary of gammatone functions&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
     &lt;span class="n"&gt;centers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;resolution&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;centers&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;resolution&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;center&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;centers&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
         &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gammatone_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;resolution&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;center&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))[:,&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newaxis&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;For illustration, see below 5 time-shifted versions of the same
gammatone (note that in the actual dictionary, we probably want the
time-shifted atoms to overlap a bit more than in this figure).&lt;/p&gt;
&lt;img alt="" class="align-center" src="images/gammatones.png" style="width: 500px;" /&gt;
&lt;p&gt;See my gammatone sparse coding library &lt;a class="reference external" href="https://github.com/jfsantos/ift6266h14/blob/master/sparse_coding/sparse_coding_gammatone.py"&gt;here&lt;/a&gt;, and an updated version
of my IPython notebook for sparse coding &lt;a class="reference external" href="https://github.com/jfsantos/ift6266h14/blob/master/sparse_coding/Sparse%20coding%20with%20a%20multiscale%20Gammatone%20dictionary.ipynb"&gt;there&lt;/a&gt; for more details. The
test code in the library reads a wave file, segments it in 2048 frames
with 50% overlap, windows each frame with a Hanning window (see next
section for details) and decomposes each frame using gammatone
atoms. The reconstruction in this example uses 200 non-zero
coefficients per frame and the dictionary has 3150 atoms. This amounts
for a compression of more than 10 times, but the reconstruction does
not sound as bad as the ones we've seen previously.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="overlapping-windows"&gt;
&lt;h2&gt;Overlapping windows&lt;/h2&gt;
&lt;p&gt;A window function is a function that has non-zero values only inside a
given interval. The most classical example of it is the rectangular
window:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
w_{rect}[n] = \begin{cases} 1, \mbox{if } n_0 \leq n \leq n_f \\
0, \mbox{ otherwise} \end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;However, a problem with the rectangular window is that it does nothing
to smooth the signal at the window borders. If we are processing a
signal on a per-frame basis and then reconstructing it by
concatenating the processed frames, nothing guarantees continuity when
we join the processed frames. These abrupt changes introduce broadband
noise bursts in our signal, which is something that we probably do not
want!&lt;/p&gt;
&lt;p&gt;A way to mitigate this problem is to do &lt;a class="reference external" href="https://ccrma.stanford.edu/~jos/parshl/Overlap_Add_Synthesis.html"&gt;overlap-add&lt;/a&gt;
synthesis. Instead of shifting a full frame at a time and using
rectangular windows, we overlap frames by a certain amount (25%, 50%,
and 75% are often used values) and multiply each frame by a smooth
window. We use window functions in such a way that the overlapped
windows always sum to unity. The figure below shows two &lt;a class="reference external" href="https://ccrma.stanford.edu/~jos/sasp/Hamming_Window.html"&gt;Hamming
windows&lt;/a&gt; with an overlap of 50% (blue and green curves), and the sum
of both windows (red curve). If we keep overlapping windows like this,
overlap-add is an identity operation (i.e., we do not change the final
result as long as we do not process the frames). Of course, in our
case we are processing the frames, but overlap-add will help a bit in
mitigating the abrupt changes between frames as we are now summing the
values in overlapping frames to reconstruct our output instead of just
connecting two non-overlapping frames.&lt;/p&gt;
&lt;img alt="" class="align-center" src="images/hamming_windows.png" style="width: 600px;" /&gt;
&lt;/div&gt;
&lt;div class="section" id="experiment-with-sparse-coding-using-gammatone-atoms"&gt;
&lt;h2&gt;Experiment with sparse coding using gammatone atoms&lt;/h2&gt;
&lt;p&gt;Based on the ideas described above, I generated a sparse-coded version
of the TIMIT dataset using my gammatone sparse coding library. I used
gammatones with 50 different cosine frequencies between 150 and 8000
Hz, timeshifts of 8 samples, and frames of length 160 with 50%
overlap. For each frame, a sparse representation using 16 non-zero
coefficients was extracted by using Orthogonal Matching Pursuit with a
sparsity constraint.&lt;/p&gt;
&lt;p&gt;This data and the one-hot encoded information about the previous,
current, and next phone were used to train an MLP with the following
characteristics:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Two rectified linear hidden layers (2150 and 950 units, respectively);&lt;/li&gt;
&lt;li&gt;Linear output layer with 950 units (one for each sparse coding coefficient);&lt;/li&gt;
&lt;li&gt;Training: batch gradient descent (batch size of 512 samples), with squared error objective;&lt;/li&gt;
&lt;li&gt;Termination criteria: 10 epochs with objective decrease lower than
&lt;span class="math"&gt;\(10^{-6}\)&lt;/span&gt;
 or 200 epochs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, something strange happened when I tried to train this
network: it has converged after 10 epochs! Of course this would be too
good to be true, which means something terrible happened instead. In
my case, the training, testing, and validation objectives did not
change at all with training iterations. I still do not know exactly
what happened, but I suspect the large amount of zeros in the input
and target values made the majority of the gradients equal to zero,
and without gradients none of the weights will change. Maybe a
different kind of initialization could solve this issue, but there are
other problems as well. Namely, this network does nothing to enforce
sparsity at the output, and in the end the output coefficients will
have a distribution that is very different from the target
coefficients (which are zero most of the time). Prof. Bengio suggested
that I could try making the output distribution the product of a
Bernoulli distribution and a Gaussian distribution: the first one
would say if that coefficient should be zero or not, and the latter
would give its value. However, he noted that this is just an arbitrary
statistical model which probably does not correspond to the real
behavior of the coefficients, and we would probably be better by
trying to estimate this distribution too (maybe with an RBM).&lt;/p&gt;
&lt;p&gt;While trying to solve these issues, I had an idea for another
architecture that could be easier to implement...&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="splitting-signal-into-spectral-envelope-and-phase"&gt;
&lt;h2&gt;Splitting signal into spectral envelope and phase&lt;/h2&gt;
&lt;p&gt;As &lt;a class="reference external" href="http://ift6266speechsynthesisjt.wordpress.com/2014/03/19/randomized-phases-preserves-speech-content-and-identity/"&gt;Jessica&lt;/a&gt; pointed out in her blog, most of the relevant
information in a speech signal is encoded in its envelope. Because of
that, we are less sensitive to phase distortions than to envelope
distortions. As we have already discussed in class, as speech envelope
variations are slower than the phase variations, some speech coding
models (such as LPC) take these facts into account by encoding the
envelope and the phase separately (and usually using a simpler model
for the phase than for envelopes).&lt;/p&gt;
&lt;p&gt;It was also brought to my attention that a recent paper &lt;a class="citation-reference" href="#han2014" id="id3"&gt;[Han2014]&lt;/a&gt; to
be presented at this year's ICASSP uses gammatone filterbank features
to find spectral masks to use in speech dereverberation. The advantage
of using gammatone filterbanks instead of a simple STFT is that with
the gammatone filterbank, we are able to fine-tune spectral resolution
at lower frequency bands (the most important band for speech
content). While speech dereverberation is a totally different topic,
the feature space used in that paper is still relevant. They are
looking for spectral masks to filter an existing signal and not on
synthesis, so they can discard the phase completely. For our project,
we cannot do that but we could work with a slightly different
approach.&lt;/p&gt;
&lt;p&gt;We have one network that is trained on spectral envelopes, using a
similar approach to that of the paper. This network is trained using
the gammatonegram, which consists of the total gammatone band energy
in all channels of our filterbank per frame. The figure below depicts
how this is done:&lt;/p&gt;
&lt;img alt="" class="align-center" src="images/filterbank.png" style="width: 700px;" /&gt;
&lt;p&gt;Here, &lt;span class="math"&gt;\(y_i[n], i = 1, \dots, 64\)&lt;/span&gt;
 are the frame energies (sum of
squared samples) for each gammatone channel (I'm using 64 channels
here as this is what was used in &lt;a class="citation-reference" href="#han2014" id="id4"&gt;[Han2014]&lt;/a&gt; and can be a good starting
point). As inputs of this network, we would use the gammatonegram of a
number of previous frames, one-hot encoded phones for these frames
(and possibly some of the next frames), and the output would be the
gammatonegram of the next frame. This is not enough to resynthesize a
speech signal as we don't have the phase, but that could be solved by
training a separate model for phases, either for an overall phase or a
per-channel phase. Resynthesis is done according to the following
signal flow diagram:&lt;/p&gt;
&lt;img alt="" class="align-center" src="images/synthesis.png" style="width: 500px;" /&gt;
&lt;p&gt;Here, &lt;span class="math"&gt;\(p_i[n], i=1, \dots, 64\)&lt;/span&gt;
 are vectors representing the
phase of each channel and &lt;span class="math"&gt;\(g_i[n], i=1, \dots, 64\)&lt;/span&gt;
 are the
amplitudes for each gammatone channel (which could be either the
&lt;span class="math"&gt;\(y_i[n]\)&lt;/span&gt;
 values computed before for each frame or a smoothed
version of them).&lt;/p&gt;
&lt;p&gt;For the network architecture, I am planning on using an MLP (possibly
with unsupervised pretraining) for the spectral envelopes. For the
phase components, I will initially try RBMs using previous phase
samples, phone codes, and speaker characteristics (pitch, gender,
etc.) as input. I expect to be able to use simpler models for the
phase (or at least be able to control this model's complexity, as I
believe there should be a tradeoff between speech quality and the
accuracy of the phase models). I have already extracted the gammatone
features from the whole database and will report results for the
spectral envelope model on my next post.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;table class="docutils citation" frame="void" id="smith2006" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[Smith2006]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;E. C. Smith and M. S. Lewicki, “Efficient auditory coding,” Nature, vol. 439, no. 7079, pp. 978–982, 2006.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="strahl2008" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[Strahl2008]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;S. Strahl and A. Mertins, “Sparse gammatone signal model optimized for English speech does not match the human auditory filters,” Brain research, vol. 1220, pp. 224–233, 2008.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="han2014" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[Han2014]&lt;/td&gt;&lt;td&gt;&lt;em&gt;(&lt;a class="fn-backref" href="#id3"&gt;1&lt;/a&gt;, &lt;a class="fn-backref" href="#id4"&gt;2&lt;/a&gt;)&lt;/em&gt; K. Han, Y. Wang and D. Wang, “Learning spectral mapping for speech dereverberation”, To appear in the Proceedings of the IEEE ICASSP 2014, 2014. Available at &lt;a class="reference external" href="http://www.cse.ohio-state.edu/~dwang/papers/HWW.icassp14.pdf"&gt;http://www.cse.ohio-state.edu/~dwang/papers/HWW.icassp14.pdf&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="ift6266"></category></entry><entry><title>Experiments with a 2 layer MLP incorporating phone information</title><link href="/exp_mlp.html" rel="alternate"></link><updated>2014-03-19T21:00:00-04:00</updated><author><name>jfsantos</name></author><id>tag:,2014-03-19:exp_mlp.html</id><summary type="html">&lt;p&gt;During the spring break I decided to run some experiments with MLPs as
generative models, using both acoustic samples and phone codes as input.
The experiment's objective is two-fold: I wanted to investigate if using
information from surrounding frames improves the models (when compared
to what our colleagues have found), and I also wanted to have a baseline
to compare to the models based on sparse coding that I have been working
on. In the experiments by
&lt;a class="reference external" href="http://ift6266hjb.wordpress.com/2014/02/10/speech-synthesis-project-description-and-first-attempt-at-a-regression-mlp/"&gt;Hubert&lt;/a&gt;,
&lt;a class="reference external" href="http://jpraymond.wordpress.com/2014/02/27/results-with-a-one-hidden-layer-neural-net/"&gt;Jean-Phillipe&lt;/a&gt;,
and &lt;a class="reference external" href="http://twuilliam.wordpress.com/2014/02/27/quick-experiment-breaking-the-sin-in-one-line/"&gt;William&lt;/a&gt;, only the acoustic samples information was used as
input.
&lt;a class="reference external" href="http://amjadmahayri.wordpress.com/2014/02/27/frame-prediction-given-phoneme-window/"&gt;Amjad&lt;/a&gt;
has already done some tests incorporating phone information, but it
seems he is using only the current phone.&lt;/p&gt;
&lt;p&gt;In my experiments, I updated
&lt;a class="reference external" href="http://vdumoulin.github.io/articles/timit-part-5"&gt;Vincent's&lt;/a&gt; dataset
implementation in order to make it provide the phones corresponding to
the current, previous, and next frame. The code can be found in my
&lt;a class="reference external" href="https://github.com/jfsantos/research"&gt;fork&lt;/a&gt;. Previously I was using
Python code to setup pylearn2 experiments, but I decided to switch to
YAML for these experiments as I didn't need to do anything fancy. The
YAML for this experiment can be found
&lt;a class="reference external" href="https://github.com/jfsantos/ift6266h14/blob/master/experiments/mlp_acoustic/ac160_ph3_rl2_malespkr.yaml"&gt;here&lt;/a&gt; and the serialized model is &lt;a class="reference external" href="https://github.com/jfsantos/ift6266h14/blob/master/experiments/mlp_acoustic/ac160_ph3_rl2_malespkr.pkl"&gt;here&lt;/a&gt;.
The dataset was configured as follows:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Frame length: 160 samples&lt;/li&gt;
&lt;li&gt;Frame overlap: 0 (not ideal, but it can be seen as a subsampling of
the complete dataset)&lt;/li&gt;
&lt;li&gt;Frames per example: 1&lt;/li&gt;
&lt;li&gt;Number of predicted samples: 1&lt;/li&gt;
&lt;li&gt;Phone information: one-hot encoded phone code for the previous,
current, and next frame&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this configuration, each example is a vector with
&lt;span class="math"&gt;\(160 + 3*62 = 346\)&lt;/span&gt;
 values. The MLP was set-up and trained as
follows:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Two rectified linear hidden layers (the first with 500 and the second
with 100 units)&lt;/li&gt;
&lt;li&gt;Linear output layer with a single unit (a single sample is predicted
for each input)&lt;/li&gt;
&lt;li&gt;Training algorithm: SGD with fixed learning rate of 0.01, running for
a maximum of 200 epochs (alternative convergence condition was set as
10 iterations with improvement lower than &lt;span class="math"&gt;\(1^{-10}\)&lt;/span&gt;
). The batch
size was of 512 examples.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Total training time for this experiment was approximately 1.15 hours,
running on a CPU (Intel Core i7-2600, 8 GB RAM, with Theano running over
MKL and using 4 cores simultaneously). As mentioned before, I considered
10 iterations without improvement as the convergence condition, which
happened by the iteration 159. A plot for the training, testing, and
validation set errors can be seen below. The errors found after
convergence (for the normalized, i.e., centered and divided by the
standard deviation) were the following:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Training error: 0.02284&lt;/li&gt;
&lt;li&gt;Test error: 0.03309&lt;/li&gt;
&lt;li&gt;Validation error: 0.05482&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A plot showing the evolution of the errors over epochs can be seen below.&lt;/p&gt;
&lt;img alt="" src="images/exp_mlp_1.png" /&gt;
&lt;p&gt;To evaluate the trained network as a synthesizer, I got a sequence of
phone codes straight out of a sentence in the validation set and used it
as input to the MLP. As I did not have a previous frame, the initial
input is a frame with only zeros on it. I played with a multiplicative
factor on the noise added to the Gaussian sampling as &lt;a class="reference external" href="http://davidtob.wordpress.com/2014/03/14/generating-one-phone-from-one-timit-speaker/"&gt;David
did&lt;/a&gt;,
as using directly the test error I ended up with bursts as can be seen
below. The following multiplicative factors were tested:
&lt;tt class="docutils literal"&gt;[0.01, 0.05, 0.1, 0.5, 1, 2, 5, 10]&lt;/tt&gt;. As using high noise levels ends
up corrupting too much the signal, I filtered them down to approximately
the telephone bandwidth (300-4000 Hz) with a &lt;span class="math"&gt;\(4^{th}\)&lt;/span&gt;
 order
Butterworth passband filter, just to reduce the overall effect of noisy
sampling. For low noise multipliers, all I got was a short burst and
then the output stays at zero. However, by increasing the noise level to
five times the mean square test error, apparently I got some more
structure: even though it has almost nothing to do with whatever should
have been synthesized, it does sound like multiple speakers babbling. The respective audio files and plots (acoustic waveform + spectrogram) can be seen below:&lt;/p&gt;
&lt;p&gt; 0.01: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/y_noise_0.01.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;
&lt;p&gt; 0.05: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/y_noise_0.05.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;
&lt;p&gt; 0.1: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/y_noise_0.1.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;
&lt;p&gt; 0.5: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/y_noise_0.5.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;
&lt;p&gt; 1.0: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/y_noise_1.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;
&lt;p&gt; 2.0: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/y_noise_2.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;
&lt;p&gt; 5.0: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/y_noise_5.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;
&lt;p&gt; 10.0: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/y_noise_10.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;&lt;img alt="" src="images/exp_mlp_2.png" /&gt;
&lt;p&gt;One interesting thing: I did the same procedure to generate an output
during training, sometime around the &lt;span class="math"&gt;\(130^{th}\)&lt;/span&gt;
 iteration. The
output generated at that stage sounded much nicer than what I got
after the training finished, but unfortunately the pickled model was
overwritten because of the way I set up my YAML file, which overwrites
the old model every time an iteration improves the objective. The only
thing I kept was the output:&lt;/p&gt;
&lt;audio controls="controls" &gt;
  &lt;source controls src="files/malespkr_rl2_not_converged.ogg"&gt; type="audio/ogg" /&gt;
  Your browser does not support the audio element.
&lt;/audio&gt;&lt;div class="section" id="next-steps"&gt;
&lt;h2&gt;Next steps&lt;/h2&gt;
&lt;p&gt;Moving forward, I will write in my next post about the (not so
successful) tests I did using sparse coding coefficients instead of
acoustic samples as inputs. I will also comment about some ideas to
incorporate more advanced models in my experiments.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="ift6266"></category></entry><entry><title>Dictionary Learning and Sparse Coding for Speech Signals</title><link href="/dictlearning.html" rel="alternate"></link><updated>2014-02-25T17:00:00-05:00</updated><author><name>jfsantos</name></author><id>tag:,2014-02-25:dictlearning.html</id><summary type="html">&lt;p&gt;Sparse signal approximations are the basis for a variety of signal
processing techniques. Such approximations are usually employed with
the objective of having a signal representation that is more
meaningful, malleable, and robust to noise than the ones obtained by
standard transform methods &lt;a class="citation-reference" href="#sturm2009" id="id1"&gt;[Sturm2009]&lt;/a&gt;. The so-called dictionary
based methods (DBM) decompose a signal into a linear combination of
waveforms through an approximation technique such as Matching Pursuit
(MP) &lt;a class="citation-reference" href="#mallat1993" id="id2"&gt;[Mallat1993]&lt;/a&gt;, Orthogonal Matching Pursuit (OMP) &lt;a class="citation-reference" href="#pati1993" id="id3"&gt;[Pati1993]&lt;/a&gt;, or
basis pursuit &lt;a class="citation-reference" href="#chen2001" id="id4"&gt;[Chen2001]&lt;/a&gt;. The collection of waveforms that can be
selected for the linear combination is called a dictionary. This
dictionary is usually overcomplete, either because it is formed by
merging complete dictionaries or because the waveforms are chosen
arbitrarily (and we have more waveforms than the length of the signal
we want to represent).&lt;/p&gt;
&lt;div class="section" id="sparse-approximation-problem-formulations"&gt;
&lt;h2&gt;Sparse approximation problem formulations&lt;/h2&gt;
&lt;p&gt;The sparse coding problem is usually formulated either as a
sparsity-constrained problem or as an error-constrained problem. The
formulations are as follows:&lt;/p&gt;
&lt;p&gt;Sparsity-constrained:
&lt;span class="math"&gt;\(\underline{\hat{\gamma}} = \underset{\underline{\gamma}}{arg\,min}\|\underline{x} - D \underline{\gamma}\|_2^2 \quad\text{s.t.}\quad   \|\underline{\gamma}\|_0 \leq K\)&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;Error-constrained:
&lt;span class="math"&gt;\(\underline{\hat{\gamma}} = \underset{\underline{\gamma}}{arg\,min}\|\underline{\gamma}\|_0 \quad\text{s.t.}\quad \|\underline{x} - D \underline{\gamma}\|_2^2 \leq \epsilon\)&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;In the first one, the idea is that we want to represent the signal by
a linear combination of up to K known waveforms. In the second
formulation, we want the squared error of the representation to be
below a certain threshold. Both formulations are useful, depending on
the problem you are trying to solve: the first one will lead to more
compact representations, while with the second one you can avoid
higher representation errors.&lt;/p&gt;
&lt;p&gt;The second formulation is also useful for applications which need
denoising: consider you have a corrupted version of your signal, and
also that you know (more or less) the signal-to-noise ratio (SNR). If
the noise is very different from the signal you are interested in and
your dictionary is optimized to represent these signals only, it may
be the case that noise is not well represented by the waveforms in
your dictionary. So, you could use the second formulation, setting
&lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt;
 as the estimated noise level, and expect that a good
part of the noise component is not going to be represented in the
sparse approximation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dictionary-learning"&gt;
&lt;h2&gt;Dictionary learning&lt;/h2&gt;
&lt;p&gt;Reconstructing a speech signal based on a learned set of segments is not
a new thing. It is done in a well-known technique called vector
quantization (VQ). In VQ, the signal is reconstructed by using only a
single atom (or &lt;em&gt;codeword&lt;/em&gt;, on the VQ literature jargon) per signal
frame. The dictionary (or &lt;em&gt;codebook&lt;/em&gt;) is usually designed by a
nearest-neighbor method, which aims to find the codebook that can
reconstruct a signal by using the codewords that have the smaller
distances to the original signal frames while minimizing the residual.
K-means is a codebook learning algorithm for VQ that solves this problem
by dividing the training samples into &lt;span class="math"&gt;\(K\)&lt;/span&gt;
 clusters of the nearest
neighbors of each of the &lt;span class="math"&gt;\(K\)&lt;/span&gt;
 items in the initial codebook. The
codebook is then updated by finding the centroid for each of the
&lt;span class="math"&gt;\(K\)&lt;/span&gt;
 clusters. These steps are ran iteratively until the algorithm
converges to a local minimum solution.&lt;/p&gt;
&lt;p&gt;For sparse coding, we want to use multiple atoms to reconstruct the
signal. In the snippet below, we generate a dictionary with 1024
waveforms by using the dictionary learning functions available in
&lt;a class="reference external" href="http://scikit-learn.org"&gt;scikit-learn&lt;/a&gt;, which is based on a paper by &lt;a class="citation-reference" href="#mairal2009" id="id5"&gt;[Mairal2009]&lt;/a&gt;. The
training data consists of two minutes of audio from the TIMIT
database; sentences were randomly chosen and then split into frames of
256 samples each.&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="c"&gt;# Build the dictionary&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sklearn.decomposition&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MiniBatchDictionaryLearning&lt;/span&gt;
&lt;span class="n"&gt;dico&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MiniBatchDictionaryLearning&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_components&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_iter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dico&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;training_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;components_&lt;/span&gt;
&lt;/pre&gt;
&lt;img alt="" class="align-center" src="images/dictlearning_5_1.png" style="width: 720px;" /&gt;
&lt;p&gt;If we take a look into some of the learned waveforms in the figure
above, we'll see that we have both low-frequency, quasiperiodic
signals (which are probably matching vowels) and signals with more
high-frequency components that look a bit noisy (probably representing
stops/fricatives).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reconstructing-speech-segments-using-sparse-coding-with-the-learned-dictionary"&gt;
&lt;h2&gt;Reconstructing speech segments using sparse coding with the learned dictionary&lt;/h2&gt;
&lt;p&gt;Now that we have a dictionary which (supposedly) is good for
representing speech signals, let's use Orthogonal Matching Pursuit
(OMP) to reconstruct a speech segment based on a linear combination of
dictionary entries. Let's get 10 seconds of audio from TIMIT (from a
segment of the set that was not in the training set) and reconstruct
it using a sparse approximation. We use the sparsity-based constraint
form, as we are more interested in representing speech in a sparse
way:&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="c"&gt;# Get sample speech segment to reconstruct&lt;/span&gt;
&lt;span class="n"&gt;test_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;210&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# Reconstruct it frame-by-frame using a linear combination of 20&lt;/span&gt;
&lt;span class="c"&gt;# atoms per frame (sparsity-constrained OMP)&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ndarray&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;test_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sklearn.decomposition&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SparseCoder&lt;/span&gt;

&lt;span class="n"&gt;coder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparseCoder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dictionary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;transform_n_nonzero_coefs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="n"&gt;transform_alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;transform_algorithm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;omp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;coder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]):&lt;/span&gt;
    &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Here are the results: you can listen above the original file and the reconstructed one.&lt;/p&gt;
&lt;p&gt; Original: &lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/orig.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt; &lt;/p&gt;
&lt;p&gt; Reconstructed with 20 atoms/frame:&lt;br&gt;
&lt;audio controls="controls" &gt;
      &lt;source src="files/reconst.ogg" type="audio/wav" /&gt;
      Your browser does not support the audio element.
&lt;/audio&gt;&lt;/p&gt;&lt;p&gt;These figures show the original signal, the reconstructed one, and the squared error:&lt;/p&gt;
&lt;img alt="" class="align-center" src="images/dictlearning_10_1.png" /&gt;
&lt;p&gt;While the reconstruction error is low for most of the time considering
we are using only 20 non-zero values per frame to represent the
signal, as opposed to using 256 samples, we can clearly hear the
reconstruction-related artifacts. However, that may be OK if all we
want with the learned dictionary is to have a sparser representation
for speech that will be used later in our synthesizer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="relationship-with-our-project-and-next-steps"&gt;
&lt;h2&gt;Relationship with our project and next steps&lt;/h2&gt;
&lt;p&gt;I started working on some experiments comparing the performance of a
sample predictor to two other predictors: one based on LPC
coefficients and the other on a sparse representation of speech. As we
discussed in class, speech has some parameters that change quickly
(source/excitation signal), while others change slowly
(articulation-related). In the first experiments prof. Bengio
suggested, we were working on an MLP-based generative model for
samples without any consideration for phones. His second suggestion
was to design a generative model for the next sample conditioned on
the previous, current, and next phone.&lt;/p&gt;
&lt;p&gt;I started developing generative models based on MLPs for the three
representations above, using one-hot encoded phones and the relative
position in time of the current phone as inputs. For the model based
on LPCs, I am planning to have a separate generative model for the
excitation signal, which is going to work pretty much like the
next-sample predictor we worked on previously; this model could also
be based on the previous, current, and next phone, previous samples,
and things such as pitch/speaker gender. Unfortunately, due to a &lt;a class="reference external" href="https://groups.google.com/forum/#!topic/pylearn-users/EZ3H8xP7gN8"&gt;bug&lt;/a&gt;
in pylearn2 I was not able to get them working yet. &lt;a class="reference external" href="http://vdumoulin.github.io/"&gt;Vincent&lt;/a&gt; said
there's already a &lt;a class="reference external" href="https://github.com/lisa-lab/pylearn2/pull/512"&gt;pull request&lt;/a&gt; which solves this
issue and it seems it will get fixed anytime soon.&lt;/p&gt;
&lt;p&gt;Last note: you can view the IPython notebook containing all the code used to generate the dictionary and the plots &lt;a class="reference external" href="http://nbviewer.ipython.org/urls/seaandsailor.com/files/dictlearning.ipynb"&gt;here&lt;/a&gt;, or &lt;a class="reference external" href="files/dictlearning.ipynb"&gt;download&lt;/a&gt; and run it interactively in your computer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;table class="docutils citation" frame="void" id="sturm2009" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[Sturm2009]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;B. L. Sturm, C. Roads, A. McLeran, and J. J. Shynk, “Analysis, Visualization, and Transformation of Audio Signals Using Dictionary-based Methods†,” Journal of New Music Research, vol. 38, no. 4, pp. 325–341, 2009.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="mallat1993" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[Mallat1993]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;S. G. Mallat and Z. Zhang, “Matching pursuits with time-frequency dictionaries,” IEEE Transactions on Signal Processing, vol. 41, no. 12, pp. 3397–3415, Dec. 1993.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="pati1993" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[Pati1993]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Y. C. Pati, R. Rezaiifar, and P. S. Krishnaprasad, “Orthogonal matching pursuit: Recursive function approximation with applications to wavelet decomposition,” in Signals, Systems and Computers, 1993. 1993 Conference Record of The Twenty-Seventh Asilomar Conference on, 1993, pp. 40–44.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="chen2001" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[Chen2001]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;S. S. Chen, D. L. Donoho, and M. A. Saunders, “Atomic decomposition by basis pursuit,” SIAM journal on scientific computing, vol. 20, no. 1, pp. 33–61, 1998.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="mairal2009" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[Mairal2009]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;J. Mairal, F. Bach, J. Ponce, and G. Sapiro, “Online dictionary learning for sparse coding,” in Proceedings of the 26th Annual International Conference on Machine Learning, 2009, pp. 689–696.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="ift6266"></category></entry><entry><title>Speech signal representations</title><link href="/initial_representation.html" rel="alternate"></link><updated>2014-02-01T18:00:00-05:00</updated><author><name>jfsantos</name></author><id>tag:,2014-02-01:initial_representation.html</id><summary type="html">&lt;p&gt;One of the objectives of our project is to learn a useful
representation from speech signals that can be used to synthesize new
(arbitrary) sentences. There are many different ways of representing
speech signals; those representations are usually tailored to specific
applications. In speech recognition, for example, we want to minimize
the variability from different speakers while keeping sufficient
information to discriminate different phonemes. In speech coding,
however, we usually want to keep information that is associated with
the speaker's identity as well as reduce the amount of data to be
stored/transmitted.&lt;/p&gt;
&lt;p&gt;Our dataset was initially distributed as frame MFCCs (input) and
one-hot encoded phonemes (labels). While this representation is
usually enough for speech recognition, I believe it is not enough for
learning a useful representation for synthesis (as briefly mentioned
by Laurent Dinh in his &lt;a class="reference external" href="http://deeprandommumbling.wordpress.com/2014/01/29/listening-to-a-vector"&gt;post&lt;/a&gt;). The reason is that MFCCs are a
destructive/lossy representation of a speech signal. First,
fundamental frequency information is completely lost, as well as
instantaneous phase. MFCCs more or less represent the energy in
different frequency channels that are considered important for human
speech (following the Mel scale &lt;a class="citation-reference" href="#stevens2005" id="id1"&gt;[Stevens2005]&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In this post, I will present some alternative speech signal
representations that may be more suitable for speech synthesis. Even
though one of our objectives is to learn a representation, we need to
understand a little bit about what has been developed by the speech
processing community, as it can serve as an inspiration.&lt;/p&gt;
&lt;div class="section" id="acoustic-samples-time-domain"&gt;
&lt;h2&gt;Acoustic samples (time domain)&lt;/h2&gt;
&lt;p&gt;Using raw acoustic samples from overlapping frames is the simplest
approach. A discrete signal &lt;span class="math"&gt;\(x[n]\)&lt;/span&gt;
 is simply a sequence of (real
or integer) numbers corresponding to the signal samples (sampled
uniformly at an arbitrary sampling rate). The usual sampling rate for
speech recognition applications is 16 kHz, while the sampling rate
used for &amp;quot;telephone speech&amp;quot; coding is 8 kHz. This is essentially the
information we find in a PCM-encoded WAV file.&lt;/p&gt;
&lt;!-- add plots --&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="images/timedomain.png" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Time-domain speech signal sampled at 16 kHz.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="images/timedomain_zoom.png" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Zoom of a 200-sample segment of the above signal.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="short-time-fourier-transform"&gt;
&lt;h2&gt;Short-time Fourier Transform&lt;/h2&gt;
&lt;p&gt;Another possible representation is to use Short-time Fourier Transform
(STFT) coefficients from overlapping frames. This is essentially the
same as using raw acoustic samples in the sense that there is no
information loss, but the representation in the frequency domain is
usually clearer for humans because we can associate the content in
different frequency bands with different phonemes. The STFT of a
discrete signal &lt;span class="math"&gt;\(x[n]\)&lt;/span&gt;
 is given by:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
STFT{x[n]}(m,\omega) = X(m,\omega) = \sum_{n=-\infty}^{\infty} x[n] w[n-m] e^{-j \omega n}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(n,\omega\)&lt;/span&gt;
 are the time and frequency indexes, and
&lt;span class="math"&gt;\(w[n]\)&lt;/span&gt;
 is the windowing function. A spectrogram is the
magnitude-squared version of this equation (i.e., without phase
information).&lt;/p&gt;
&lt;p&gt;Spectrograms can be done using windows with different lengths. This is
related to the &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Short-time_Fourier_transform#Resolution_issues"&gt;Gabor (or Heisenberg-Gabor)&lt;/a&gt; limit: we cannot
simultaneously localize a signal in both time and frequency domains
with a high degree of certainty. Therefore, we usually have to use
different window lengths depending on what we want to analyze: wide
windows have better frequency resolution and bad time resolution,
while the opposite happens for short windows. A possible compromise is
to choose a single window length that has sufficient resolution for
the target application.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="images/specgram.png" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Spectrogram (using a 20 ms rectangular window) of the speech signal above.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="linear-predictive-coding"&gt;
&lt;h2&gt;Linear Predictive Coding&lt;/h2&gt;
&lt;p&gt;Linear Predictive Coding &lt;a class="citation-reference" href="#o1988linear" id="id2"&gt;[o1988linear]&lt;/a&gt; coefficients + residual
(basically excitation information). LPC is based on the source-filter
model of speech production, which assumes a speech signal is produced
by filtering a series of pulses (and eventually noise bursts). The LPC
coefficients are related to the position of the articulators in the
mouth (e.g., tongue, palate, lips), while the pitch/noise information
is related to how the vocal tract is excited. This is usually
represented as an auto-regressive (AR) model with order &lt;span class="math"&gt;\(p\)&lt;/span&gt;
:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
x[n] = \sum_{k=1}^{p} a_k x[n-k]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(a[k]\)&lt;/span&gt;
 are the model's coefficients. LPCs are computed for each speech frame based on a least-squares method:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\arg\min_{a_k} \sum_{-\infty}^\infty [x[n] - \sum_{k=1}^p a_k x[n-k]]^2
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Because of its error criteria, LPC also has problems to represent the
phase of acoustic signals (by squaring the error, we are modeling the
spectral magnitude of the signal, and not the phase). For this reason,
LPC speech may sound artificial when resynthesized. More robust
methods are used nowadays, such as the code-excited linear prediction
(CELP) &lt;a class="citation-reference" href="#valin2006speex" id="id3"&gt;[valin2006speex]&lt;/a&gt;. These methods, for example, use
psychoacoustics-inspired techniques to shape the coding noise to
frequency regions where the human auditory system is more tolerant. In
CELP, the residual is not transmitted directly, but represented as
entries in two codebooks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wavelets"&gt;
&lt;h2&gt;Wavelets&lt;/h2&gt;
&lt;p&gt;Them main purpose of a wavelet transform is to decompose arbitrary
signals into localized contributions that can be labelled by a scale
(or resolution) parameter &lt;a class="citation-reference" href="#mallat1989theory" id="id4"&gt;[mallat1989theory]&lt;/a&gt;. The representation
achieved through the wavelet transform can be seen as hierarchical: at
a coarse resolution, we have an idea of “context”, while with highest
resolution we can see more details. This is achieved by decomposing
the original signal using a set of functions well-localized both in
time and frequency (the so-called wavelets).&lt;/p&gt;
&lt;p&gt;Discrete wavelet transforms are implemented as a cascade of digital
filters with transfer functions derived from a discrete &amp;quot;mother
wavelet&amp;quot;. The figure below shows an example. Check also the &lt;a class="reference internal" href="#notebook"&gt;notebook&lt;/a&gt;
for an example of wavelet decomposition of the audio signal shown
above.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="images/Wavelets_-_Filter_Bank.png" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Filter bank used by a discrete wavelet transform with 3 levels of decomposition (image from the&lt;/em&gt; &lt;a class="reference external" href="http://en.wikipedia.org/wiki/File:Wavelets_-_Filter_Bank.png"&gt;WikiMedia Commons&lt;/a&gt; &lt;em&gt;)&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="sparse-coding-and-dictionary-based-methods"&gt;
&lt;h2&gt;Sparse coding and dictionary-based methods&lt;/h2&gt;
&lt;p&gt;Sparse signal approximations are the basis for a variety of signal
processing techniques. Such approximations are usually employed with
the objective of having a signal representation that is more
meaningful, malleable, and robust to noise than the ones obtained by
standard transform methods &lt;a class="citation-reference" href="#sturm" id="id5"&gt;[Sturm]&lt;/a&gt;. The so-called
dictionary-based methods (DBM) decompose a signal into a linear
combination of waveforms through an approximation technique such as
Matching Pursuit (MP) &lt;a class="citation-reference" href="#mallat1993" id="id6"&gt;[Mallat1993]&lt;/a&gt; or Orthogonal Matching Pursuit
(OMP) &lt;a class="citation-reference" href="#pati1993" id="id7"&gt;[Pati1993]&lt;/a&gt;. The collection of waveforms that can be
selected for the linear combination is called a dictionary. This
dictionary is usually overcomplete, either because it is formed by
merging complete dictionaries or because the functions are chosen
arbitrarily.&lt;/p&gt;
&lt;p&gt;I will talk more about sparse coding and dictionary-based methods
later, since sparse coding is one of the methods we'll see in the
course.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ipython-notebook"&gt;
&lt;span id="notebook"&gt;&lt;/span&gt;&lt;h2&gt;IPython notebook&lt;/h2&gt;
&lt;p&gt;An IPython notebook with examples for all the representations
described here (except sparse coding) is available on my &lt;a class="reference external" href="https://github.com/jfsantos/ift6266h14"&gt;GitHub
repo&lt;/a&gt;. You will need to install the packages &lt;a class="reference external" href="http://www.pybytes.com/pywavelets/"&gt;PyWavelets&lt;/a&gt; and
&lt;a class="reference external" href="https://github.com/cournape/talkbox"&gt;scikits.talkbox&lt;/a&gt; (both are available at PyPI) to be able to run it. If you just want to take a look without interacting with the code, you can access it &lt;a class="reference external" href="http://nbviewer.ipython.org/github/jfsantos/ift6266h14/blob/master/notebooks/Speech%20representation%20examples.ipynb"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;table class="docutils citation" frame="void" id="stevens2005" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[Stevens2005]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;S. S. Stevens, J. Volkmann, and E. B. Newman, “A Scale for the Measurement of the Psychological Magnitude Pitch,” The Journal of the Acoustical Society of America, vol. 8, no. 3, pp. 185–190, Jun. 2005.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="o1988linear" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[o1988linear]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;D. O’Shaughnessy, “Linear predictive coding,” IEEE Potentials, vol. 7, no. 1, pp. 29–32, Feb. 1988.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="valin2006speex" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[valin2006speex]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;J.-M. Valin, “Speex: a free codec for free speech,” in Australian National Linux Conference, Dunedin, New Zealand, 2006.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="mallat1989theory" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[mallat1989theory]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;S. G. Mallat, “A theory for multiresolution signal decomposition: the wavelet representation,” Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 11, no. 7, pp. 674–693, 1989.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="sturm" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[Sturm]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;B. L. Sturm, C. Roads, A. McLeran, and J. J. Shynk, “Analysis, Visualization, and Transformation of Audio Signals Using Dictionary-based Methods†,” Journal of New Music Research, vol. 38, no. 4, pp. 325–341, 2009.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="mallat1993" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[Mallat1993]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;S. G. Mallat and Z. Zhang, “Matching pursuits with time-frequency dictionaries,” IEEE Transactions on Signal Processing, vol. 41, no. 12, pp. 3397–3415, Dec. 1993.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="pati1993" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id7"&gt;[Pati1993]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Y. C. Pati, R. Rezaiifar, and P. S. Krishnaprasad, “Orthogonal matching pursuit: Recursive function approximation with applications to wavelet decomposition,” in Signals, Systems and Computers, 1993. 1993 Conference Record of The Twenty-Seventh Asilomar Conference on, 1993, pp. 40–44.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="ift6266"></category></entry><entry><title>Personal research journal: deep learning for speech synthesis</title><link href="/intro_ift6266.html" rel="alternate"></link><updated>2014-01-25T15:00:00-05:00</updated><author><name>jfsantos</name></author><id>tag:,2014-01-25:intro_ift6266.html</id><summary type="html">&lt;p&gt;This is the introduction to a series of reports on my experiments on
deep learning methods for speech synthesis. These experiments are part
of my coursework for Dr. Yoshua Bengio's &lt;a class="reference external" href="http://ift6266h14.wordpress.com"&gt;Representation Learning&lt;/a&gt;
course at Université de Montréal. All the related code is going to be
posted at a &lt;a class="reference external" href="https://github.com/jfsantos/ift6266h14"&gt;GitHub repository&lt;/a&gt; as well.&lt;/p&gt;
&lt;p&gt;Please visit the &lt;a class="reference external" href="/tag/ift6266.html"&gt;ift6266 tag page&lt;/a&gt; for a list of all the posts
related to this project.&lt;/p&gt;
</summary><category term="ift6266"></category></entry><entry><title>My Emacs configuration for MATLAB, LaTeX, and Python</title><link href="/emacs-config.html" rel="alternate"></link><updated>2013-07-28T12:00:00-04:00</updated><author><name>jfsantos</name></author><id>tag:,2013-07-28:emacs-config.html</id><summary type="html">&lt;p&gt;Emacs is a main part of my daily life. I write code and papers using
it, so you could say that anything that my research will leave
(hopefully) for the next generations was probably typed using it. Not
anybody loves Emacs, and I will not try to convince you to use
it. This post is just a brief overview of all the Emacs goodness I
found during the last years and I believe you should be using too, if
you use Emacs to write anything in MATLAB, LaTeX and Python.&lt;/p&gt;
&lt;p&gt;First things first: &lt;a class="reference external" href="http://batsov.com/prelude/"&gt;Prelude&lt;/a&gt; is the base configuration I have been
using during the last years. Prelude is a sane base configuration that
includes a lot of good things and saves a &lt;strong&gt;lot&lt;/strong&gt; of time. If you use
any UNIX-like operating system, installing it is a matter of running
this command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;curl -L http://git.io/epre | sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as long as you already have Emacs 24 (if you are still using Emacs 23,
go on and update it ASAP!). Note that this installs it to the default
Emacs configuration folder (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/.emacs.d&lt;/span&gt;&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;I know that I said Prelude is a sane base configuration, but I don't
like two things it includes by default: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;guru-mode&lt;/span&gt;&lt;/tt&gt; (which basically
disables keyboard arrows to force you to learn how to navigate using
default Emacs commands) and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;whitespace-mode&lt;/span&gt;&lt;/tt&gt; (which renders
whitespace characters with visible glyphs). To disable these (and to
add anything to a Prelude-based Emacs configuration), edit (you may
have to create it first) &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/.emacs.d/personal/init.el&lt;/span&gt;&lt;/tt&gt; and add
the following lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;;; Disable guru-mode (I like using arrows :p)
(setq prelude-guru nil)
;; Disable whitespace-mode
(setq prelude-whitespace nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another thing you should do is to enable the Prelude modules you want
to use (and disable the ones you are never going to need). To do it,
copy &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/.emacs.d/sample/prelude-modules.el&lt;/span&gt;&lt;/tt&gt; to
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/.emacs.d/prelude-modules.el&lt;/span&gt;&lt;/tt&gt;, remove the comment symbols
(&lt;tt class="docutils literal"&gt;;&lt;/tt&gt;) from the modules you want to use and comment the ones you
don't want.&lt;/p&gt;
&lt;div class="section" id="matlab"&gt;
&lt;h2&gt;MATLAB&lt;/h2&gt;
&lt;p&gt;While MATLAB has a decent GUI (and a nice graphical debugger), the
editor is not very good (it does code completion, some hinting, and
that's all). Also, in my experience, the GUI is not reliable under
Linux. &lt;a class="reference external" href="http://matlab-emacs.sourceforge.net/"&gt;matlab-emacs&lt;/a&gt; is an Emacs package that adds a major mode to
edit MATLAB code and also enables a MATLAB shell from inside Emacs. To
install it, you can run this &lt;a class="reference external" href="http://matlab-emacs.cvs.sourceforge.net/viewvc/*checkout*/matlab-emacs/matlab-emacs/dl_emacs_support.m?revision=1.2&amp;amp;pathrev=MAIN"&gt;script&lt;/a&gt; from MATLAB to download all the
files and save them to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/.emacs.d/personal/matlab-emacs&lt;/span&gt;&lt;/tt&gt;. Then,
to make Emacs automatically open &lt;tt class="docutils literal"&gt;.m&lt;/tt&gt; files using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;matlab-mode&lt;/span&gt;&lt;/tt&gt;
and configure &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;matlab-shell&lt;/span&gt;&lt;/tt&gt;, add the following lines to
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/.emacs.d/personal/init.el&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;;; Setting up matlab-mode
(add-to-list &amp;#39;load-path &amp;quot;~/.emacs.d/personal/matlab-emacs&amp;quot;)
(load-library &amp;quot;matlab-load&amp;quot;)
(custom-set-variables
 &amp;#39;(matlab-shell-command-switches &amp;#39;(&amp;quot;-nodesktop -nosplash&amp;quot;)))
(add-hook &amp;#39;matlab-mode-hook &amp;#39;auto-complete-mode)
(setq auto-mode-alist
    (cons
     &amp;#39;(&amp;quot;\\.m$&amp;quot; . matlab-mode)
     auto-mode-alist))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is much more in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;matlab-emacs&lt;/span&gt;&lt;/tt&gt; than just code completion and
the shell. You can use Emacs to debug MATLAB code, send selected
regions to execute on MATLAB, and much more. Take a look at the following articles to have a better idea of the other features:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://blog.angjookanazawa.com/post/8815280589/productivity-matlab-emacs-integration-more"&gt;http://blog.angjookanazawa.com/post/8815280589/productivity-matlab-emacs-integration-more&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://blogs.mathworks.com/community/2009/09/14/matlab-emacs-integration-is-back/"&gt;http://blogs.mathworks.com/community/2009/09/14/matlab-emacs-integration-is-back/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python"&gt;
&lt;h2&gt;Python&lt;/h2&gt;
&lt;p&gt;Prelude includes a Python module, but if you look deeper you will see
it just enables &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;subword-mode&lt;/span&gt;&lt;/tt&gt; (to make word moving commands jump
inside CamelCase words) and disables &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;electric-indent-mode&lt;/span&gt;&lt;/tt&gt; (to
disable automatic indentation after a line break), which is not much
(and you may even disagree about this setup!). If you would like code
completion, refactoring, code hinting, code navigation, inline
documentation, and more, &lt;a class="reference external" href="https://github.com/jorgenschaefer/elpy"&gt;Elpy&lt;/a&gt; is a good option. Installing it
depends on two steps, as it has both a Emacs and a Python package. You
can simply follow these &lt;a class="reference external" href="https://github.com/jorgenschaefer/elpy/wiki/Installation"&gt;instructions&lt;/a&gt; and be happy with a boatload
of features! You will also need to install either &lt;a class="reference external" href="http://rope.sourceforge.net/"&gt;Rope&lt;/a&gt; or &lt;a class="reference external" href="https://github.com/davidhalter/jedi"&gt;Jedi&lt;/a&gt;
(from the Python side), which Elpy uses for code completion. Rope
appears to have better refactoring features, so that's what I
use. Note that you have to install Elpy and Rope to a place on your
default &lt;tt class="docutils literal"&gt;PYTHONPATH&lt;/tt&gt;, which you can do by running &lt;tt class="docutils literal"&gt;pip
install &lt;span class="pre"&gt;--user&lt;/span&gt; elpy rope&lt;/tt&gt;. This will install the packages to
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$HOME/.local/lib/python2.7/site-packages&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="latex"&gt;
&lt;h2&gt;LaTeX&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.gnu.org/software/auctex/"&gt;AUCTeX&lt;/a&gt;, an amazing package for writing LaTeX using Emacs, is
already included on Prelude (as long as you activate the LaTeX
module). It supports auto-completing LaTex expressions and has a
&amp;quot;magic compilation&amp;quot; command: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C-c&lt;/span&gt; &lt;span class="pre"&gt;C-c&lt;/span&gt;&lt;/tt&gt;. It checks the status of your
folder and runs either latex/pdflatex, bibtex, or opens the output
file.&lt;/p&gt;
&lt;p&gt;RefTeX is another extension but it ships with Emacs since Emacs
24.3. If your &lt;tt class="docutils literal"&gt;.tex&lt;/tt&gt; file includes a reference to a &lt;tt class="docutils literal"&gt;.bib&lt;/tt&gt; file,
you can use the command &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C-c&lt;/span&gt; [&lt;/tt&gt; to add a citation to any of the
references listed on that file.&lt;/p&gt;
&lt;p&gt;I also recommend using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;writegood-mode&lt;/span&gt;&lt;/tt&gt; to detect use of weasel
words, duplicate words and passive voice. You can install it by simply
running the command &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;M-x&lt;/span&gt; &lt;span class="pre"&gt;package-install&lt;/span&gt; &lt;span class="pre"&gt;writegood-mode&lt;/span&gt;&lt;/tt&gt; directly
from Emacs (as long as you are using Prelude as described previously).&lt;/p&gt;
&lt;p&gt;This is the configuration I use for fine-tuning AUCTeX (use pdflatex by default, use RefTeX, configure viewers, enable &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;writegood-mode&lt;/span&gt;&lt;/tt&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;;; LaTeX configuration
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)

(add-hook &amp;#39;LaTeX-mode-hook &amp;#39;visual-line-mode)
(add-hook &amp;#39;LaTeX-mode-hook &amp;#39;flyspell-mode)
(add-hook &amp;#39;LaTeX-mode-hook &amp;#39;LaTeX-math-mode)
(add-hook &amp;#39;LaTeX-mode-hook &amp;#39;TeX-source-correlate-mode)

(add-hook &amp;#39;LaTeX-mode-hook &amp;#39;turn-on-reftex)
(setq reftex-plug-into-AUCTeX t)
(setq TeX-PDF-mode t)

(setq TeX-output-view-style
    (quote
     ((&amp;quot;^pdf$&amp;quot; &amp;quot;.&amp;quot; &amp;quot;evince -f %o&amp;quot;)
      (&amp;quot;^html?$&amp;quot; &amp;quot;.&amp;quot; &amp;quot;iceweasel %o&amp;quot;))))

;; Setting up writegood-mode
(require &amp;#39;writegood-mode)
(global-set-key &amp;quot;\C-cg&amp;quot; &amp;#39;writegood-mode)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="extras"&gt;
&lt;h2&gt;Extras&lt;/h2&gt;
&lt;p&gt;If you want to tinker and add your own features to Emacs, you will
probably want to learn some Emacs Lisp. This is a nice and brief
tutorial to get a grasp of it:
&lt;a class="reference external" href="http://bzg.fr/learn-emacs-lisp-in-15-minutes.html"&gt;http://bzg.fr/learn-emacs-lisp-in-15-minutes.html&lt;/a&gt; (and this should be
useful even if you don't want to create your own extensions, but just
add some fancy things to your Emacs config!).&lt;/p&gt;
&lt;/div&gt;
</summary><category term="development"></category></entry><entry><title>WinPython: a portable scientific Python distribution for Windows</title><link href="/winpython.html" rel="alternate"></link><updated>2013-06-25T21:00:00-04:00</updated><author><name>jfsantos</name></author><id>tag:,2013-06-25:winpython.html</id><summary type="html">&lt;p&gt;Recently I developed a &lt;a class="reference external" href="http://bitbucket.org/jfsantos/sitest"&gt;piece of software&lt;/a&gt; for administering speech
intelligibility listening tests and discovered a small issue: I am not
an administrator of the computer that I am going to use for the tests,
so I cannot install any software. Since the computer is running
Windows, there is no standard Python distribution there. I already
knew &lt;a class="reference external" href="http://portablepython.com"&gt;Portable Python&lt;/a&gt;, which is (surprise!) a portable Python
distribution that can be run from a USB storage device. However, the
first version of my code was using PyAudio, which was not included in
this distribution. Since this module uses binary wrappers to
PortAudio, installation is not as straightforward as copying a bunch
of .py files, and I could not find out how to install it to my USB
drive... but then, WinPython came to the rescue!&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://code.google.com/p/winpython/"&gt;WinPython&lt;/a&gt; is a complete
NumPy/SciPy portable development environment, which also includes an
IDE (&lt;a class="reference external" href="https://code.google.com/p/spyderlib/"&gt;Spyder&lt;/a&gt;), my favorite
version control system (Mercurial) and Qt tools for GUI
development. However, what made me like it so much is the WinPython
Package Manager (&lt;a class="reference external" href="https://code.google.com/p/winpython/wiki/WPPM"&gt;WPPM&lt;/a&gt;), which allows one
to install any packages that can be installed with &lt;em&gt;easy_install&lt;/em&gt;,
&lt;em&gt;pip&lt;/em&gt;, or &lt;em&gt;distutils&lt;/em&gt; standard installers. The latter is specially
interesting because &lt;em&gt;distutils&lt;/em&gt; installers include binary
dependencies, so you do not need a C/C++ compiler. If scientific
computing is your thing, maybe the library you need is just a visit to
&lt;a class="reference external" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/"&gt;Christoph Gohlke's page&lt;/a&gt; away (which was my case
with PyAudio).&lt;/p&gt;
&lt;p&gt;Another interesting feature is the possibility of converting your
portable distribution to a more &amp;quot;conventional&amp;quot; Python installation on
Windows by adding some keys to the registry (this is also done through
the WinPython Control Panel). Also, both Python 2.7 and Python 3.3 are
available, with support to 32 and 64 bit Windows XP/7/8.&lt;/p&gt;
</summary><category term="development"></category></entry><entry><title>Using Vagrant to make reproducible development and test environments</title><link href="/using-vagrant.html" rel="alternate"></link><updated>2013-05-19T16:00:00-04:00</updated><author><name>jfsantos</name></author><id>tag:,2013-05-19:using-vagrant.html</id><summary type="html">&lt;p&gt;Working with research-grade software is hard sometimes. We all have
heard before (more than once, probably) the &amp;quot;it worked perfectly on my
computer&amp;quot; story. The problem is that setting up a development
environment takes a lot of time, and usually you'll end up forgetting
which libraries and pieces of software you needed to install to get
things running... and if you cannot figure out what did you have to do
to get it working, let alone your colleagues that may need to use your
code someday!&lt;/p&gt;
&lt;p&gt;One simple way to try to mitigate this problem is to use virtual
machines (VMs) as development and test environments. By developing
your code on a VM, you can later distribute it instead of distributing
your code only. I know that's not how serious people develop software,
but let's be honest here: many research-grade software is developed on
a &amp;quot;code and forget&amp;quot; paradigm. As soon as you publish your
paper/thesis/whatever, you'll forget about it. Then, you will update
your operating system, hardware, libraries. Then, months or years
later, you will come up with a wonderful idea and think &amp;quot;I already
have software for doing half of that!&amp;quot; just to find out that it does
not work anymore... That's not nice.&lt;/p&gt;
&lt;p&gt;Of course, developing and distributing software using VMs has other
advantages. For collaborative projects, you can make sure everybody is
working with the same versions of the libraries and
compilers/interpreters. Also, it is a way of having access to another
operating system such as Linux (if, like me, you are stuck with
Windows for the time being).&lt;/p&gt;
&lt;p&gt;One way of following this approach would be to have a &amp;quot;base&amp;quot; virtual
machine and then, every time you start a new software project, you do
this:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Make a copy from the base environment.&lt;/li&gt;
&lt;li&gt;Install everything that you need on that copy, manually.&lt;/li&gt;
&lt;li&gt;Develop your software, tests, etc.&lt;/li&gt;
&lt;li&gt;Package the result and distribute (or archive) it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, making copies and installing everything by hand is boring, so
I chose to use an amazing tool called Vagrant to do a lot of this
boring work for me. It is able to download base virtual machines (for
example, a barebones Ubuntu VM), configure them, and install software
on it automatically. All you need to do is write a couple of
configuration files.&lt;/p&gt;
&lt;div class="section" id="setting-up-vagrant-on-windows"&gt;
&lt;h2&gt;Setting up Vagrant on Windows&lt;/h2&gt;
&lt;p&gt;In order to set up and properly use Vagrant on Windows, you will need
to install it and also VirtualBox, which is the default VM
provider. It is also recommended that you install Git, which comes
with a SSH client for Windows (that you can use to access the VM
instead of using the default VirtualBox interface). You can find the
installers on the following URLs:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Vagrant &lt;a class="reference external" href="http://downloads.vagrantup.com/tags/v1.2.2"&gt;http://downloads.vagrantup.com/tags/v1.2.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;VirtualBox &lt;a class="reference external" href="http://www.virtualbox.org/wiki/Downloads"&gt;http://www.virtualbox.org/wiki/Downloads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Git &lt;a class="reference external" href="http://www.git-scm.com/downloads"&gt;http://www.git-scm.com/downloads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By default, Vagrant will keep the downloaded base VMs at your home
folder (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;%USERPROFILE%\.vagrant.d&lt;/span&gt;&lt;/tt&gt;), but you can choose another
folder by setting the environment variable &lt;tt class="docutils literal"&gt;%VAGRANT_HOME%&lt;/tt&gt; on
Windows. Also, VirtualBox will store your VMs at
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;%USERPROFILE%\VirtualBox&lt;/span&gt; VMs&lt;/tt&gt;, but you can change it by opening
VirtualBox preferences and changing the default VM folder. As both
folders will end up storing a lot of data depending on how many VMs
you use, it may be interesting to change both before starting to use
the approach presented here.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="example-vm"&gt;
&lt;h2&gt;Example VM&lt;/h2&gt;
&lt;p&gt;I wrote a simple configuration file to use as an example for this
post. The machine configuration is all done on this file (which is
called &lt;em&gt;Vagrantfile&lt;/em&gt;) except for the software installation, which is
done using a simple shell script. As you can see below, the
configuration is very simple. To test it, just download both files,
fire up a Git Bash session, go to this directory and run &lt;tt class="docutils literal"&gt;vagrant
up&lt;/tt&gt;. This will start up the virtual machine and install all the
required software on it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Vagrant::Config.run do |config|
  # All Vagrant configuration is done here. The most common configuration
  # options are documented and commented below. For a complete reference,
  # please see the online documentation at vagrantup.com.

  # Every Vagrant virtual environment requires a box to build off of.
  config.vm.box = &amp;quot;precise32&amp;quot;

  # The url from where the &amp;#39;config.vm.box&amp;#39; box will be fetched if it
  # doesn&amp;#39;t already exist on the user&amp;#39;s system.
  config.vm.box_url = &amp;quot;http://files.vagrantup.com/precise32.box&amp;quot;

  # Amount of RAM on the VM
  config.vm.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--memory&amp;quot;, 512] # 512 MB RAM

  # Boot with a GUI so you can see the screen. (Default is headless)
  # config.vm.boot_mode = :gui

  # Assign this VM to a host-only network IP, allowing you to access it
  # via the IP. Host-only networks can talk to the host machine as well as
  # any other machines on the same network, but cannot be accessed (through this
  # network interface) by any external networks.
  # config.vm.network :hostonly, &amp;quot;192.168.33.10&amp;quot;

  # Assign this VM to a bridged network, allowing you to connect directly to a
  # network using the host&amp;#39;s network device. This makes the VM appear as another
  # physical device on your network.
  config.vm.network :bridged

  # Forward a port from the guest to the host, which allows for outside
  # computers to access the VM, whereas host only networking does not.
  config.vm.forward_port 8000, 8000

  # Share an additional folder to the guest VM. The first argument is
  # an identifier, the second is the path on the guest to mount the
  # folder, and the third is the path on the host to the actual folder.
  # config.vm.share_folder &amp;quot;v-data&amp;quot;, &amp;quot;/vagrant_data&amp;quot;, &amp;quot;../data&amp;quot;

  # Enable provisioning with a shell script. Add the sequence of
  # commands you want to run to provision the VM to provision.sh
  config.vm.provision :shell, :path =&amp;gt; &amp;quot;provision.sh&amp;quot;
end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For this example, we will simply add commands to install GNU Octave on
the VM to the file &lt;tt class="docutils literal"&gt;provision.sh&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;DEBIAN_FRONTEND&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;noninteractive
apt-get update &amp;gt; /dev/null
apt-get -y install octave
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="accessing-the-vm-transferring-files-between-it-and-the-host"&gt;
&lt;h2&gt;Accessing the VM, transferring files between it and the host&lt;/h2&gt;
&lt;p&gt;The command &lt;tt class="docutils literal"&gt;vagrant up&lt;/tt&gt; leaves the machine running after the
setup. To access it, just run &lt;tt class="docutils literal"&gt;ssh &lt;span class="pre"&gt;-p&lt;/span&gt; 2222 vagrant&amp;#64;localhost&lt;/tt&gt; (the
password is &lt;em&gt;vagrant&lt;/em&gt;). You can also access the VM using VirtualBox's
interface. In case you need graphical output or audio, this is the
simplest way of accessing it (you should add &lt;tt class="docutils literal"&gt;config.vm.boot_mode =
gui&lt;/tt&gt; to your Vagrantfile, too). Otherwise, SSH will work fine.&lt;/p&gt;
&lt;p&gt;Another magic trick done by Vagrant is to set up shared folders, so
sending files to the VM (and getting them from the VM) is easy. The
folder where you store the configuration files is mounted with
read-write access on the VM at &lt;tt class="docutils literal"&gt;/vagrant&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;To shut down the VM, use the commands &lt;tt class="docutils literal"&gt;vagrant halt&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;vagrant
suspend&lt;/tt&gt; (the latter will save the machine state, which will be
reloaded on the next time you start it).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="final-considerations"&gt;
&lt;h2&gt;Final considerations&lt;/h2&gt;
&lt;p&gt;That's it, basically. You can use &lt;a class="reference external" href="https://bitbucket.org/jfsantos/vagrant-example"&gt;these files&lt;/a&gt; as a starting point to
design your own virtual machines. There are more complex ways of
provisioning VMs, using tools such as Chef and Puppet, but that's out
of the scope of this blog post. For an excellent example using Puppet,
check out this &lt;a class="reference external" href="https://github.com/gavinln/stats_py_vm"&gt;Github project&lt;/a&gt; (which, in fact, is the project that
inspired me to use VMs for software development in my research!). It
sets up a VM with statistics and numerical libraries for Python.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="development"></category></entry></feed>